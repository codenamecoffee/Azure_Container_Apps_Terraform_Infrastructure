# CI solo en main; la validación de PR la dispara la Branch Policy.
trigger:
  branches:
    include:
      - main

# Evitamos doble ejecución: PR no lo dispara el YAML.
pr: none

resources:
  containers:
    - container: runner
      image: schoolof.azurecr.io/runner:latest
      endpoint: sc-acr-schoolof
      options: --user 0:0

variables:
  serviceConnection: sc-school-of-2025-mvd
  tf_working_dir: infra
  environmentName: dev

  backend_rg: SchoolOf
  backend_storage: schooloftfstates
  backend_container: tfstate-schoolof2025-terraform
  backend_key: $(Build.Repository.Name)/$(environmentName).tfstate

  DO_DESTROY: 'false'

stages:
# =========================
# PLAN (SOLO en PR)
# =========================
- stage: Plan
  displayName: Validate & Plan
  condition: eq(variables['Build.Reason'], 'PullRequest')
  jobs:
  - job: plan
    displayName: Terraform Plan
    pool: { name: Default }
    container: runner
    steps:
      - checkout: self
        fetchDepth: 0

      # --- Instalar clave SSH para clonar módulos ---
      - task: DownloadSecureFile@1
        name: fetchSshKey
        displayName: "Fetch SSH private key"
        inputs:
          secureFile: 'ado-runner-private'

      - bash: |
          set -euo pipefail
          mkdir -p ~/.ssh
          cp "$(fetchSshKey.secureFilePath)" ~/.ssh/id_ed25519_terraform_modules
          chmod 600 ~/.ssh/id_ed25519_terraform_modules
          ssh-keyscan -H ssh.dev.azure.com >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts
          cat > ~/.ssh/config <<'CFG'
          Host ssh.dev.azure.com
            HostName ssh.dev.azure.com
            User git
            IdentityFile ~/.ssh/id_ed25519_terraform_modules
            IdentitiesOnly yes
            PubkeyAuthentication yes
            StrictHostKeyChecking yes
          CFG
          chmod 600 ~/.ssh/config
        displayName: "Configure SSH for Azure Repos"

      - task: AzureCLI@2
        displayName: Verificar si container existe
        inputs:
          azureSubscription: $(serviceConnection)
          addSpnToEnvironment: true
          scriptType: bash
          scriptLocation: inlineScript
          inlineScript: |
            set -euo pipefail
            az storage container create \
              --name "$(backend_container)" \
              --account-name "$(backend_storage)" \
              --auth-mode login \
              --public-access off 1>/dev/null || true

      - task: AzureCLI@2
        displayName: Terraform plan
        env:
          GIT_SSH_COMMAND: 'ssh -i ~/.ssh/id_ed25519_terraform_modules -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes'
        inputs:
          azureSubscription: $(serviceConnection)
          addSpnToEnvironment: true
          scriptType: bash
          scriptLocation: inlineScript
          inlineScript: |
            set -euo pipefail

            terraform -version || { echo "Terraform no está en PATH en la imagen"; exit 1; }

            OIDC_FILE="$(Pipeline.Workspace)/ado_oidc.token"
            umask 077
            printf '%s' "${idToken:-}" > "$OIDC_FILE"

            export ARM_USE_OIDC=true
            export ARM_TENANT_ID="$tenantId"
            export ARM_CLIENT_ID="$servicePrincipalId"
            export ARM_SUBSCRIPTION_ID="$(az account show --query id -o tsv)"
            export ARM_OIDC_TOKEN_FILE_PATH="$OIDC_FILE"
            unset ARM_USE_CLI || true

            cd "$(tf_working_dir)"
            terraform fmt -check -recursive
            terraform init \
              -backend-config="resource_group_name=$(backend_rg)" \
              -backend-config="storage_account_name=$(backend_storage)" \
              -backend-config="container_name=$(backend_container)" \
              -backend-config="key=$(backend_key)"
            terraform workspace select "$(environmentName)" || terraform workspace new "$(environmentName)"
            terraform validate

            PLAN_OUT="$(Pipeline.Workspace)/tfplan.tfplan"
            if [ -f "../env/$(environmentName).tfvars" ]; then
              terraform plan -var-file="../env/$(environmentName).tfvars" -out="$PLAN_OUT" -lock-timeout=20m
            else
              terraform plan -out="$PLAN_OUT" -lock-timeout=20m
            fi

            PR_ID="$(System.PullRequest.PullRequestId)"
            if [ -n "$PR_ID" ]; then
              BLOB_PR="plans/pr-${PR_ID}.tfplan"
              az storage blob upload \
                --account-name "$(backend_storage)" \
                --container-name "$(backend_container)" \
                --name "$BLOB_PR" \
                --file "$PLAN_OUT" \
                --auth-mode login --overwrite
            fi
      
      - task: Bash@3
        displayName: Configure SSH for Terraform module
        inputs:
          targetType: 'inline'
          script: |
            # Crear directorio SSH
            mkdir -p ~/.ssh
            chmod 700 ~/.ssh
            
            # Agregar host key para ssh.dev.azure.com
            ssh-keyscan ssh.dev.azure.com >> ~/.ssh/known_hosts
            
            # Configurar clave privada
            echo "$(FG_MG_SSH_PRIVATE_KEY)" > ~/.ssh/id_rsa
            chmod 600 ~/.ssh/id_rsa
            
            # Iniciar SSH agent
            eval $(ssh-agent -s)
            ssh-add ~/.ssh/id_rsa
      
      - task: PublishBuildArtifacts@1
        displayName: Publicar tfplan
        inputs:
          pathToPublish: $(Pipeline.Workspace)/tfplan.tfplan
          artifactName: tfplan
          publishLocation: Container

# =========================
# APPLY (SOLO en main)
# =========================
- stage: Apply
  displayName: Apply (main)
  dependsOn: []
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - job: apply
    pool: { name: Default }
    container: runner
    steps:
      - checkout: self
        fetchDepth: 0

      - task: DownloadSecureFile@1
        name: fetchSshKey
        displayName: "Fetch SSH private key"
        inputs:
          secureFile: 'ado-runner-private'

      - bash: |
          set -euo pipefail
          mkdir -p ~/.ssh
          cp "$(fetchSshKey.secureFilePath)" ~/.ssh/id_ed25519_terraform_modules
          chmod 600 ~/.ssh/id_ed25519_terraform_modules
          ssh-keyscan -H ssh.dev.azure.com >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts
          cat > ~/.ssh/config <<'CFG'
          Host ssh.dev.azure.com
            HostName ssh.dev.azure.com
            User git
            IdentityFile ~/.ssh/id_ed25519_terraform_modules
            IdentitiesOnly yes
            PubkeyAuthentication yes
            StrictHostKeyChecking yes
          CFG
          chmod 600 ~/.ssh/config
        displayName: "Configure SSH for Azure Repos"

      - task: AzureCLI@2
        displayName: PR
        env:
          ADO_PAT: $(ADO_PAT)
        inputs:
          azureSubscription: $(serviceConnection)
          addSpnToEnvironment: true
          scriptType: bash
          scriptLocation: inlineScript
          inlineScript: |
            set -euo pipefail
            if [ -z "${ADO_PAT:-}" ]; then
              echo "No hay ADO_PAT; fallback a re-plan."
              exit 0
            fi

            ORG_URL="$(System.CollectionUri)"
            PROJ="$(System.TeamProject)"
            REPO_NAME="$(Build.Repository.Name)"
            COMMIT="$(Build.SourceVersion)"

            if ! command -v jq >/dev/null 2>&1; then
              apt-get update -y >/dev/null && apt-get install -y jq >/dev/null
            fi

            # Helper para curl con chequeo de HTTP
            apicall() {
              local url="$1"
              local out http
              out="$(mktemp)"; http="$(curl -sS -u :${ADO_PAT} -H 'Accept: application/json' -o "$out" -w '%{http_code}' "$url")" || http=000
              if [ "$http" != "200" ]; then
                echo "API ${url} → HTTP $http; fallback a re-plan."
                rm -f "$out"; return 1
              fi
              cat "$out"; rm -f "$out"
            }

            # 1) repoId por nombre
            REPOS_JSON="$(apicall "${ORG_URL}${PROJ}/_apis/git/repositories?api-version=7.0")" || exit 0
            REPO_ID="$(echo "$REPOS_JSON" | jq -r --arg NAME "$REPO_NAME" '.value[] | select(.name==$NAME) | .id')"
            if [ -z "${REPO_ID:-}" ] || [ "$REPO_ID" = "null" ]; then
              echo "No repoId; fallback a re-plan."; exit 0
            fi

            # 2) PR asociado al commit de merge
            PRS_JSON="$(apicall "${ORG_URL}${PROJ}/_apis/git/repositories/${REPO_ID}/commits/${COMMIT}/pullRequests?api-version=7.0")" || exit 0
            PR_ID="$(echo "$PRS_JSON" | jq -r '.value[0].pullRequestId // empty')"
            if [ -z "${PR_ID:-}" ]; then
              echo "Sin PR asociado; fallback a re-plan."; exit 0
            fi
            echo "PR asociado: #$PR_ID"

            BLOB_PR="plans/pr-${PR_ID}.tfplan"
            PLAN_OUT="$(Pipeline.Workspace)/tfplan-pr.tfplan"

            # Descargar plan; si falla, fallback silencioso a re-plan
            if ! az storage blob download \
                  --account-name "$(backend_storage)" \
                  --container-name "$(backend_container)" \
                  --name "$BLOB_PR" \
                  --file "$PLAN_OUT" \
                  --auth-mode login --no-progress 2>/dev/null; then
              echo "No se pudo descargar $BLOB_PR; fallback a re-plan."
              exit 0
            fi
            echo "##vso[task.setvariable variable=PR_PLAN_PATH]$PLAN_OUT"

      - task: AzureCLI@2
        displayName: Terraform apply
        env:
          GIT_SSH_COMMAND: 'ssh -i ~/.ssh/id_ed25519_terraform_modules -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes'
        inputs:
          azureSubscription: $(serviceConnection)
          addSpnToEnvironment: true
          scriptType: bash
          scriptLocation: inlineScript
          inlineScript: |
            set -euo pipefail
            terraform -version || { echo "Terraform no está en PATH en la imagen"; exit 1; }

            OIDC_FILE="$(Pipeline.Workspace)/ado_oidc.token"
            umask 077
            printf '%s' "${idToken:-}" > "$OIDC_FILE"

            export ARM_USE_OIDC=true
            export ARM_TENANT_ID="$tenantId"
            export ARM_CLIENT_ID="$servicePrincipalId"
            export ARM_SUBSCRIPTION_ID="$(az account show --query id -o tsv)"
            export ARM_OIDC_TOKEN_FILE_PATH="$OIDC_FILE"
            unset ARM_USE_CLI || true

            cd "$(tf_working_dir)"
            terraform init \
              -backend-config="resource_group_name=$(backend_rg)" \
              -backend-config="storage_account_name=$(backend_storage)" \
              -backend-config="container_name=$(backend_container)" \
              -backend-config="key=$(backend_key)"
            terraform workspace select "$(environmentName)" || terraform workspace new "$(environmentName)"

            if [ -n "${PR_PLAN_PATH:-}" ] && [ -f "${PR_PLAN_PATH:-}" ]; then
              terraform apply -input=false -auto-approve "${PR_PLAN_PATH}"
            else
              if [ -f "../env/$(environmentName).tfvars" ]; then
                terraform plan -var-file="../env/$(environmentName).tfvars" -out="$(Pipeline.Workspace)/tfplan.tfplan" -lock-timeout=20m
              else
                terraform plan -out="$(Pipeline.Workspace)/tfplan.tfplan" -lock-timeout=20m
              fi
              terraform apply -input=false -auto-approve "$(Pipeline.Workspace)/tfplan.tfplan"
            fi

# =========================
# DESTROY (manual)
# =========================
- stage: Destroy
  displayName: Destroy (manual)
  dependsOn: []
  condition: and(succeeded(), eq(variables['DO_DESTROY'], 'true'))
  jobs:
  - job: destroy
    pool: { name: Default }
    container: runner
    steps:
      - checkout: self
        fetchDepth: 0

      - task: DownloadSecureFile@1
        name: fetchSshKey
        displayName: "Fetch SSH private key"
        inputs:
          secureFile: 'ado-runner-private'

      - bash: |
          set -euo pipefail
          mkdir -p ~/.ssh
          cp "$(fetchSshKey.secureFilePath)" ~/.ssh/id_ed25519_terraform_modules
          chmod 600 ~/.ssh/id_ed25519_terraform_modules
          ssh-keyscan -H ssh.dev.azure.com >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts
          cat > ~/.ssh/config <<'CFG'
          Host ssh.dev.azure.com
            HostName ssh.dev.azure.com
            User git
            IdentityFile ~/.ssh/id_ed25519_terraform_modules
            IdentitiesOnly yes
            PubkeyAuthentication yes
            StrictHostKeyChecking yes
          CFG
          chmod 600 ~/.ssh/config
        displayName: "Configure SSH for Azure Repos"

      - task: AzureCLI@2
        displayName: Terraform destroy
        env:
          GIT_SSH_COMMAND: 'ssh -i ~/.ssh/id_ed25519_terraform_modules -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes'
        inputs:
          azureSubscription: $(serviceConnection)
          addSpnToEnvironment: true
          scriptType: bash
          scriptLocation: inlineScript
          inlineScript: |
            set -euo pipefail
            terraform -version || { echo "Terraform no está en PATH en la imagen"; exit 1; }
            OIDC_FILE="$(Pipeline.Workspace)/ado_oidc.token"
            umask 077
            printf '%s' "${idToken:-}" > "$OIDC_FILE"
            export ARM_USE_OIDC=true
            export ARM_TENANT_ID="$tenantId"
            export ARM_CLIENT_ID="$servicePrincipalId"
            export ARM_SUBSCRIPTION_ID="$(az account show --query id -o tsv)"
            export ARM_OIDC_TOKEN_FILE_PATH="$OIDC_FILE"
            unset ARM_USE_CLI || true
            cd "$(tf_working_dir)"
            terraform init \
              -backend-config="resource_group_name=$(backend_rg)" \
              -backend-config="storage_account_name=$(backend_storage)" \
              -backend-config="container_name=$(backend_container)" \
              -backend-config="key=$(backend_key)"
            terraform workspace select "$(environmentName)" || terraform workspace new "$(environmentName)"
            if [ -f "../env/$(environmentName).tfvars" ]; then
              terraform destroy -var-file="../env/$(environmentName).tfvars" -auto-approve -lock-timeout=20m
            else
              terraform destroy -auto-approve -lock-timeout=20m
            fi
